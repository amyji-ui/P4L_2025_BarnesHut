// Amy Ji
// test parsers are generated by ChatGPT 5.0
// https://chatgpt.com/share/68fe7a48-d45c-800a-9dc1-b85b1d3d039d

package main

import (
    "os"
    "io/fs"
    "bufio"
    "strings"
    "strconv"
    "testing"
    "math"
    "fmt"
)

// --- Safe Reader Utilities ---

// stripComment trims any '#' comment from a line and cleans whitespace.
func stripComment(line string) string {
    if idx := strings.Index(line, "#"); idx != -1 {
        line = line[:idx]
    }
    return strings.TrimSpace(line)
}

// ReadDirectory lists files in a directory.
func ReadDirectory(dir string) []fs.DirEntry {
    files, err := os.ReadDir(dir)
    if err != nil {
        panic(err)
    }
    return files
}

// readFloat reads the first numeric token from a file.
func readFloat(file string) float64 {
    f, _ := os.Open(file)
    defer f.Close()
    sc := bufio.NewScanner(f)
    for sc.Scan() {
        line := stripComment(sc.Text())
        if line == "" {
            continue
        }
        val, _ := strconv.ParseFloat(line, 64)
        return val
    }
    return 0
}

// readFloatPair reads one line containing two floats.
func readFloatPair(file string) (float64, float64) {
    f, _ := os.Open(file)
    defer f.Close()
    sc := bufio.NewScanner(f)
    for sc.Scan() {
        line := stripComment(sc.Text())
        if line == "" {
            continue
        }
        parts := strings.Fields(line)
        if len(parts) < 2 {
            continue
        }
        x, _ := strconv.ParseFloat(parts[0], 64)
        y, _ := strconv.ParseFloat(parts[1], 64)
        return x, y
    }
    return 0, 0
}

// readTwoPairs reads two coordinate pairs (two lines, each with x y).
func readTwoPairs(file string) (OrderedPair, OrderedPair) {
    f, _ := os.Open(file)
    defer f.Close()
    sc := bufio.NewScanner(f)

    var pairs []OrderedPair
    for sc.Scan() {
        line := stripComment(sc.Text())
        if line == "" {
            continue
        }
        parts := strings.Fields(line)
        if len(parts) < 2 {
            continue
        }
        x, _ := strconv.ParseFloat(parts[0], 64)
        y, _ := strconv.ParseFloat(parts[1], 64)
        pairs = append(pairs, OrderedPair{x, y})
    }
    if len(pairs) < 2 {
        panic("Not enough coordinate pairs in " + file)
    }
    return pairs[0], pairs[1]
}

func readTriple(path string) (float64, float64, float64) {
    f, err := os.Open(path)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    sc := bufio.NewScanner(f)
    for sc.Scan() {
        line := strings.TrimSpace(strings.Split(sc.Text(), "#")[0])
        if line == "" {
            continue
        }
        vals := strings.Fields(line)
        if len(vals) < 3 {
            continue
        }
        a, _ := strconv.ParseFloat(vals[0], 64)
        b, _ := strconv.ParseFloat(vals[1], 64)
        c, _ := strconv.ParseFloat(vals[2], 64)
        return a, b, c
    }
    return 0, 0, 0
}

func readStars(file string) []*Star {
    fmt.Println("Reading stars from:", file) // add this
    f, _ := os.Open(file)
    defer f.Close()
    sc := bufio.NewScanner(f)
    var stars []*Star
    for sc.Scan() {
        line := stripComment(sc.Text())
        if line == "" {
            continue
        }
        parts := strings.Fields(line)
        if len(parts) < 3 {
            fmt.Println("⚠️ Skipping malformed line:", line)
            continue
        }
        x, _ := strconv.ParseFloat(parts[0], 64)
        y, _ := strconv.ParseFloat(parts[1], 64)
        m, _ := strconv.ParseFloat(parts[2], 64)
        stars = append(stars, &Star{position: OrderedPair{x, y}, mass: m})
    }
    if len(stars) == 0 {
        panic("No valid star data found in " + file)
    }
    return stars
}

func almostEqual(a, b, tol float64) bool {
    return math.Abs(a-b) <= tol
}

func readNextDataLine(sc *bufio.Scanner) string {
    for sc.Scan() {
        line := strings.TrimSpace(strings.Split(sc.Text(), "#")[0])
        if line != "" {
            return line
        }
    }
    return ""
}

// === Test 1: CalcDistance ===
func TestCalcDistance(t *testing.T) {
    inputs := ReadDirectory("Tests/CalcDistance/input")
    for _, file := range inputs {
        p1, p2 := readTwoPairs("Tests/CalcDistance/input/" + file.Name())
        want := readFloat("Tests/CalcDistance/output/" + file.Name())
        got := CalcDistance(p1, p2)
        if !almostEqual(got, want, 1e-3) {
            t.Errorf("CalcDistance(%v,%v)=%v, want %v", p1, p2, got, want)
        }
    }
}


// === Test 2: SumStarMasses ===
func TestSumStarMasses(t *testing.T) {
    inputs := ReadDirectory("Tests/SumStarMasses/input")
    for _, file := range inputs {
        f, _ := os.Open("Tests/SumStarMasses/input/" + file.Name())
        defer f.Close()
        sc := bufio.NewScanner(f)
        var stars []*Star

        for sc.Scan() {
            line := sc.Text()
            // remove comments if present
            if idx := strings.Index(line, "#"); idx != -1 {
                line = line[:idx]
            }
            line = strings.TrimSpace(line)
            if line == "" {
                continue
            }

            fields := strings.Fields(line)
            if len(fields) < 3 {
                continue
            }

            // parse the third value as mass
            m, _ := strconv.ParseFloat(fields[2], 64)
            stars = append(stars, &Star{mass: m})
        }

        want := readFloat("Tests/SumStarMasses/output/" + file.Name())
        got := SumStarMasses(stars)

        if !almostEqual(got, want, 1e-3) {
            t.Errorf("SumStarMasses %s got %v, want %v", file.Name(), got, want)
        }
    }
}

// === Test 3: CenterOfMass ===
func TestCenterOfMass(t *testing.T) {
    inputs := ReadDirectory("Tests/CenterOfMass/input")
    for _, file := range inputs {
        stars := readStars("Tests/CenterOfMass/input/" + file.Name())
        wantx, wanty := readFloatPair("Tests/CenterOfMass/output/" + file.Name())
        got := CenterOfMass(stars)
        if !almostEqual(got.x, wantx, 1e-3) || !almostEqual(got.y, wanty, 1e-3) {
            t.Errorf("CenterOfMass %s got (%v,%v), want (%v,%v)",
                file.Name(), got.x, got.y, wantx, wanty)
        }
    }
}


// === Test 4: ChildIndex ===
func TestChildIndex(t *testing.T) {
    inputs := ReadDirectory("Tests/ChildIndex/input")
    for _, file := range inputs {
        f, _ := os.Open("Tests/ChildIndex/input/" + file.Name())
        defer f.Close()
        sc := bufio.NewScanner(f)
        sc.Scan()
        qParts := strings.Fields(sc.Text())
        x, _ := strconv.ParseFloat(qParts[0], 64)
        y, _ := strconv.ParseFloat(qParts[1], 64)
        w, _ := strconv.ParseFloat(qParts[2], 64)
        sc.Scan()
        pParts := strings.Fields(sc.Text())
        px, _ := strconv.ParseFloat(pParts[0], 64)
        py, _ := strconv.ParseFloat(pParts[1], 64)
        want := int(readFloat("Tests/ChildIndex/output/" + file.Name()))
        got := ChildIndex(Quadrant{x, y, w}, OrderedPair{px, py})
        if got != want {
            t.Errorf("ChildIndex got %v, want %v", got, want)
        }
    }
}

// === Test 5: SplitQuadrant ===
func TestSplitQuadrant(t *testing.T) {
    inputs := ReadDirectory("Tests/SplitQuadrant/input")
    for _, file := range inputs {
        f, err := os.Open("Tests/SplitQuadrant/input/" + file.Name())
        if err != nil {
            t.Fatalf("failed to open file: %v", err)
        }
        defer f.Close()

        sc := bufio.NewScanner(f)
        sc.Scan()
        vals := strings.Fields(sc.Text())
        x, _ := strconv.ParseFloat(vals[0], 64)
        y, _ := strconv.ParseFloat(vals[1], 64)
        w, _ := strconv.ParseFloat(vals[2], 64)

        quads := SplitQuadrant(Quadrant{x, y, w})

        want := readFloat("Tests/SplitQuadrant/output/" + file.Name())
        if !almostEqual(quads[0].width, want, 1e-3) {
            t.Errorf("SplitQuadrant width got %v, want %v", quads[0].width, want)
        }
    }
}


// === Test 6: BuildNode ===
func TestBuildNode(t *testing.T) {
    inputs := ReadDirectory("Tests/BuildNode/input")
    for _, file := range inputs {
        f, err := os.Open("Tests/BuildNode/input/" + file.Name())
        if err != nil {
            t.Fatalf("cannot open %s: %v", file.Name(), err)
        }
        defer f.Close()

        sc := bufio.NewScanner(f)
        var qx, qy, qw float64
        var stars []*Star
        lineNum := 0

        // Parse quadrant and star data
        for sc.Scan() {
            line := strings.TrimSpace(strings.Split(sc.Text(), "#")[0])
            if line == "" {
                continue
            }
            fields := strings.Fields(line)
            lineNum++
            if lineNum == 1 {
                // first line is quadrant
                qx, _ = strconv.ParseFloat(fields[0], 64)
                qy, _ = strconv.ParseFloat(fields[1], 64)
                qw, _ = strconv.ParseFloat(fields[2], 64)
            } else {
                // star data: x y mass
                x, _ := strconv.ParseFloat(fields[0], 64)
                y, _ := strconv.ParseFloat(fields[1], 64)
                m, _ := strconv.ParseFloat(fields[2], 64)
                stars = append(stars, &Star{position: OrderedPair{x, y}, mass: m})
            }
        }

        root := BuildNode(Quadrant{qx, qy, qw}, stars)
        if root == nil {
            t.Fatalf("%s: BuildNode returned nil", file.Name())
        }

        // Read expected: total_mass center_x center_y num_leafs
        wantMass, wantX, wantY, wantLeafs := readQuadruple("Tests/BuildNode/output/" + file.Name())

        // Gather actual results
        gotMass := root.star.mass
        gotX := root.star.position.x
        gotY := root.star.position.y
        gotLeafs := countLeafNodes(root)

        if !almostEqual(gotMass, wantMass, 1e-3) ||
            !almostEqual(gotX, wantX, 1e-1) ||
            !almostEqual(gotY, wantY, 1e-1) ||
            float64(gotLeafs) != wantLeafs {
            t.Errorf("%s: got (mass=%.3f, x=%.3f, y=%.3f, leafs=%d), want (%.3f, %.3f, %.3f, %.0f)",
                file.Name(), gotMass, gotX, gotY, gotLeafs, wantMass, wantX, wantY, wantLeafs)
        }
    }
}

// Helper: count number of leaves
func countLeafNodes(n *Node) int {
    if n == nil {
        return 0
    }
    if n.children == nil {
        return 1
    }
    leafs := 0
    for _, c := range n.children {
        leafs += countLeafNodes(c)
    }
    return leafs
}

// Helper: read 4 float values (mass, x, y, leafs)
func readQuadruple(path string) (float64, float64, float64, float64) {
    f, err := os.Open(path)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    sc := bufio.NewScanner(f)
    for sc.Scan() {
        line := strings.TrimSpace(strings.Split(sc.Text(), "#")[0])
        if line == "" {
            continue
        }
        vals := strings.Fields(line)
        if len(vals) < 4 {
            continue
        }
        a, _ := strconv.ParseFloat(vals[0], 64)
        b, _ := strconv.ParseFloat(vals[1], 64)
        c, _ := strconv.ParseFloat(vals[2], 64)
        d, _ := strconv.ParseFloat(vals[3], 64)
        return a, b, c, d
    }
    return 0, 0, 0, 0
}

// === Test 7: CalcForce ===
func TestCalcForce(t *testing.T) {
    inputs := ReadDirectory("Tests/CalcForce/input")
    for _, file := range inputs {
        p1, p2 := readTwoPairs("Tests/CalcForce/input/" + file.Name())
        wantx, wanty := readFloatPair("Tests/CalcForce/output/" + file.Name())

        s1 := &Star{position: p1, mass: 2}
        s2 := &Star{position: p2, mass: 3}
        got := CalcForce(s1, s2, 3.67e-11)

        if !almostEqual(got.x, wantx, 1e-3) || !almostEqual(got.y, wanty, 1e-3) {
            t.Errorf("CalcForce(%v,%v)=(%v,%v), want=(%v,%v)", p1, p2, got.x, got.y, wantx, wanty)
        }
    }
}


// === Test 8: UpdatePosition ===
func TestUpdatePosition(t *testing.T) {
    inputs := ReadDirectory("Tests/UpdatePosition/input")
    for _, file := range inputs {
        f, err := os.Open("Tests/UpdatePosition/input/" + file.Name())
        if err != nil {
            t.Fatalf("failed to open %s: %v", file.Name(), err)
        }
        defer f.Close()

        sc := bufio.NewScanner(f)
        for sc.Scan() {
            line := sc.Text()
            if idx := strings.Index(line, "#"); idx != -1 {
                line = line[:idx]
            }
            line = strings.TrimSpace(line)
            if line == "" {
                continue
            }

            vals := strings.Fields(line)
            if len(vals) < 5 {
                t.Fatalf("%s: expected 5 values (x y vx vy dt), got %v", file.Name(), len(vals))
            }

            px, _ := strconv.ParseFloat(vals[0], 64)
            py, _ := strconv.ParseFloat(vals[1], 64)
            vx, _ := strconv.ParseFloat(vals[2], 64)
            vy, _ := strconv.ParseFloat(vals[3], 64)
            dt, _ := strconv.ParseFloat(vals[4], 64)

            star := &Star{position: OrderedPair{px, py}}
            wantx, wanty := readFloatPair("Tests/UpdatePosition/output/" + file.Name())
            got := UpdatePosition(star, OrderedPair{0, 0}, OrderedPair{vx, vy}, dt)

            if !almostEqual(got.x, wantx, 1e-3) || !almostEqual(got.y, wanty, 1e-3) {
                t.Errorf("%s: got (%.3f, %.3f), want (%.3f, %.3f)",
                    file.Name(), got.x, got.y, wantx, wanty)
            }
        }
    }
}


